# -*- coding: utf-8 -*-
"""
Created on Mon Apr 23 00:43:48 2019

@author: EG
"""
import numpy as np
#from numpy.random import randn
import pandas as pd
#from pandas import Series, DataFrame
#import matplotlib.pyplot as plt
#from matplotlib import rcParams


#Start off by assumning 10ft wide doors with 2 ft inbetween doors

NumOfDoor = 177
DoorsWide = 11
DoorWidth = 12
DoorSpace = 2
DockWidth = DoorsWide*DoorWidth + DoorSpace*(DoorsWide+1)
Y = 10 # the space from the door to the lane dedicated for forklift travel
#print(DockWidth)

AllDoors = range(1, NumOfDoor+1)
#print(AllDoors)

NumDoorNoWide = (NumOfDoor - (DoorsWide * 2))
#print(NumDoorNoWide)

Half = NumDoorNoWide / 2
#print(Half)

SideDoors1 = range(1, DoorsWide + 1)
#print(SideDoors1)
SideDoors2 = range(NumOfDoor + 1 - DoorsWide, NumOfDoor + 1)
#print(SideDoors2)
SideDoors = SideDoors1 + SideDoors2
#print(SideDoors)

Doors = [e for e in AllDoors if e not in SideDoors]
#print(Doors)

OddDoors = [num for num in Doors if num % 2 == 1]
#print(OddDoors)

EvenDoors = [num for num in Doors if num % 2 == 0]
#print(EvenDoors)

address_UL = 'C:\Users\gamboa\Desktop\IE 396 Senior Design\IND_UL.csv'
address_LD = 'C:\Users\gamboa\Desktop\IE 396 Senior Design\IND_LD.csv'

# Next couple lines imports the data from the files and names the columns of the dataframe
UL_Main_Data = pd.read_csv(address_UL)
UL_Main_Data.columns = ['Pro','UL','Dock','Ship','Pcs','Wgt','ULTrlr','ULDoor','UnloadTS','UnLoadDOW','LoadInterval','Org','UnloadDate','UnloadTime']

LD_Main_Data = pd.read_csv(address_LD)
LD_Main_Data.columns = ['Pro','L','Dock','Ship','Pcs','Wgt','LdTrlr','LdDoor','LoadTS','LoadDOW','LoadInterval','Dest','LoadTo','LoadToParent','LoadDate','LoadTime']

ULData = UL_Main_Data[pd.to_numeric(UL_Main_Data['ULDoor'], errors='coerce').notnull()]
#ULDoorAndPro = ULData.drop(['UL','Org','Dock','Ship','Pcs','Wgt','ULTrlr','UnloadTS','UnLoadDOW','LoadInterval','UnloadDate','UnloadTime'], axis = 1)
ULDoorAndPro = ULData.drop(['UL','Org','Dock','Ship','ULTrlr','UnloadTS','UnLoadDOW','LoadInterval','UnloadDate','UnloadTime'], axis = 1)

#print(ULDoorAndPro)

LDdata = LD_Main_Data[pd.to_numeric(LD_Main_Data['LdDoor'], errors='coerce').notnull()]
#LDdoorAndPro = LDdata.drop(['L','Dock','Ship','Pcs','Wgt','LdTrlr','LoadTS','LoadDOW','LoadInterval','Dest', 'LoadToParent', 'LoadTo', 'LoadDate','LoadTime'], axis = 1)
LDdoorAndPro = LDdata.drop(['L','Dock','Ship','LdTrlr','LoadTS','LoadDOW','LoadInterval','Dest', 'LoadToParent', 'LoadDate','LoadTime'], axis = 1)

#print(LDdoorAndPro)

#LDdoorNum = LD_Main_Data['LdDoor'] # Gets Load door numbers
#DoorNumFull = pd.concat([ULDoorNum, LDdoorNum]) # Combines both to get full list of doors being used to unload and load
Df_ULandLD = ULDoorAndPro.Pro.isin(LDdoorAndPro.Pro) # Checks if all the Pros that come in leave at some point


ULDoorAndPro['UL_to_LD'] = Df_ULandLD # Add the row of Booleans to the original df
#print(ULDoorAndPro)
ULDoorAndPro = ULDoorAndPro.reset_index(drop = True)
ULDoorAndPro_True = ULDoorAndPro[ULDoorAndPro.UL_to_LD] # Only get the true values
ULDoorAndPro_True = ULDoorAndPro_True.reset_index(drop = True)
ULemptyCount = pd.DataFrame(index = ULDoorAndPro.index.values, columns = ['Count']) # Create empty dataframe with index from ULDoorAndPro_True
ULemptyCount = ULemptyCount.fillna(0)

for a in range(len(ULemptyCount)):
    if a == 0:
        ULemptyCount.iloc[a] = 1
    else:
        if ULDoorAndPro.loc[a-1,'Pro'] == ULDoorAndPro.loc[a,'Pro']:
            ULemptyCount.iloc[a] = 1 + ULemptyCount.iloc[a-1]
        else:
            ULemptyCount.iloc[a] = 1

#print(ULemptyCount)
ULDoorAndPro['Count'] = ULemptyCount
#print(ULDoorAndPro)

Df_LDandUL = LDdoorAndPro.Pro.isin(ULDoorAndPro_True.Pro)
LDdoorAndPro['LD_to_UL'] = Df_LDandUL
LDdoorAndPro = LDdoorAndPro.reset_index(drop = True)
LDdoorAndPro_True = LDdoorAndPro[LDdoorAndPro.LD_to_UL]
LDdoorAndPro_True = LDdoorAndPro_True.reset_index(drop = True)
LDemptyCount = pd.DataFrame(index = LDdoorAndPro.index.values, columns = ['Count']) # Create empty dataframe with index from LDdoorAndPro_True
LDemptyCount = LDemptyCount.fillna(0)
for a in range(len(LDemptyCount)):
    if a == 0:
        LDemptyCount.iloc[a] = 1
    else:
        if LDdoorAndPro.loc[a-1,'Pro'] == LDdoorAndPro.loc[a,'Pro']:
            LDemptyCount.iloc[a] = 1 + LDemptyCount.iloc[a-1]
        else:
            LDemptyCount.iloc[a] = 1
LDdoorAndPro['Count'] = LDemptyCount
#print(LDemptyCount)
#print(LDdoorAndPro)

#FromTo_v1 = pd.merge(ULDoorAndPro_True,LDdoorAndPro_True[['Pro','LdDoor']],on = 'Pro', how = 'inner')
#FromTo = FromTo_v1.drop_duplicates(subset=['Pro','ULDoor','LdDoor'], keep = 'first')
#ULDoorAndPro_True['LdDoor'] = LDdoorAndPro.LdDoor
#FromTo = ULDoorAndPro_True
#FromTo = FromTo.drop(['UL_to_LD'])
#print(FromTo_v1)
FromTo = pd.merge(ULDoorAndPro, LDdoorAndPro, on = ['Pro', 'Count']) # Shortcut to above stuff
print(FromTo) 
#FromTo = FromTo.drop(['UL_to_LD', 'Count','LD_to_UL'])

distance = pd.DataFrame(index = FromTo.index.values, columns = ['Distance'])
distance = distance.fillna(0)

for b in range(len(FromTo)):
    #print(type(FromTo.loc[b,'ULDoor']))
    if int(FromTo.loc[b,'ULDoor']) in EvenDoors and int(FromTo.loc[b,'LdDoor']) in EvenDoors:
        x = abs(EvenDoors.index(int(FromTo.loc[b,'ULDoor'])) - EvenDoors.index(int(FromTo.loc[b,'LdDoor'])))
        if x < 1:
           distance.loc[b] = 0
        else:
           distance.loc[b] = DoorWidth * x + DoorSpace * x + 2 * Y
    elif int(FromTo.loc[b,'ULDoor']) in OddDoors and int(FromTo.loc[b,'LdDoor']) in OddDoors:
        x = abs(OddDoors.index(int(FromTo.loc[b,'ULDoor'])) - OddDoors.index(int(FromTo.loc[b,'LdDoor'])))
        if x < 1:
           distance.loc[b] = 0
        else:
           distance.loc[b] = DoorWidth * x + DoorSpace * x + 2 * Y
    elif int(FromTo.loc[b,'ULDoor']) in SideDoors and int(FromTo.loc[b,'LdDoor']) in SideDoors:
        distance.loc[b] = None
    else:
        if int(FromTo.loc[b,'ULDoor']) in OddDoors and int(FromTo.loc[b,'LdDoor']) in EvenDoors:
            x = abs(OddDoors.index(int(FromTo.loc[b,'ULDoor'])) - EvenDoors.index(int(FromTo.loc[b,'LdDoor'])))
            distance.loc[b] = DoorWidth * x + DoorSpace * x + 2 * Y + DockWidth
        elif int(FromTo.loc[b,'ULDoor']) in EvenDoors and int(FromTo.loc[b,'LdDoor']) in OddDoors:
            x = abs(EvenDoors.index(int(FromTo.loc[b,'ULDoor'])) - OddDoors.index(int(FromTo.loc[b,'LdDoor'])))
            distance.loc[b] = DoorWidth * x + DoorSpace * x + 2 * Y + DockWidth
        
        #x = max(x1, x2)
        

#print(distance)
FromTo['Distance'] = distance * 2
speed = 26400 # Avg speed of a forklift

WgtPerPiece = FromTo['Wgt_y']/FromTo['Pcs_y']
h = WgtPerPiece.mean()
#print(h)
FromTo['c_ij'] = FromTo['Distance'] / (h*speed)# Cost in man hours to move a pound of freight from door i to door j 

#FromTo now contains c_ij and f_ij. To get sum_i (sum_j(c_ij*f_ij)), add up the columns fo these sections
labor_cost_travel_df = FromTo['c_ij'] * FromTo['Wgt_y']

#print(labor_cost_travel_df)
labor_cost_travel = labor_cost_travel_df.sum()
#print(labor_cost_travel)
#print(FromTo.columns)

pairs = FromTo.filter(['Pro','ULDoor', 'LdDoor', 'LoadTo','Wgt_y'], axis = 1)
#print(FromTo.ULDoor)
newpairs = pairs

i = 0
while i < 50:
    import random
    temp1 = random.randint(0,len(pairs))
    temp2 = random.randint(0,len(pairs))
    temp3 = random.randint(0,len(Doors))
    temp4 = random.randint(0,len(Doors))
    #newpairs.ULDoor.iloc[temp1], newpairs.LdDoor.iloc[temp2] = newpairs.ULDoor.iloc[temp2], newpairs.LdDoor.iloc[temp1]
    #newpairs.loc[temp1,'ULDoor'], newpairs.loc[temp2,'LdDoor']
    newpairs.ULDoor = pd.to_numeric(newpairs.ULDoor, errors = 'coerce')
    #newpairs['ULDoor'] = newpairs['ULDoor'].apply(lambda w: [y if y != newpairs.loc[temp1,'ULDoor'] else newpairs.loc[temp2,'LdDoor'] in w])
    #newpairs['LdDoor'] = newpairs['LdDoor'].apply(lambda w: [y if y != newpairs.loc[temp2,'LdDoor'] else newpairs.loc[temp1,'ULDoor'] in w])
    #newpairs['ULDoor'] = newpairs['ULDoor'].apply(lambda w: [r if r != newpairs.loc[1,'ULDoor'] else newpairs.loc[2,'LdDoor'] in w])
    #newpairs['LdDoor'] = newpairs['LdDoor'].apply(lambda w: [r if r != newpairs.loc[2,'LdDoor'] else newpairs.loc[1,'ULDoor'] in w])
    
    newp = np.array(newpairs['ULDoor'].values.tolist())
    newpp = np.array(newpairs['LdDoor'].values.tolist())
    #print newp,newpp
    TempPairs = newpairs
    newpairs['ULDoor'],newpairs['LdDoor'] = np.where(newp == newpairs.loc[temp1,'ULDoor'],newpairs.loc[temp2,'LdDoor'],newp).tolist(),np.where(newpp == newpairs.loc[temp2,'LdDoor'],newpairs.loc[temp1,'ULDoor'],newpp).tolist()
    
    #newpairs['LdDoor'] = np.where(newpp == newpairs.loc[2,'LdDoor'],newpairs.loc[1,'ULDoor'],newpp).tolist()
    
    #print newpairs
    
    distance2 = pd.DataFrame(index = FromTo.index.values, columns = ['Distance'])
    distance2 = distance2.fillna(0)
    for b in range(len(newpairs)):
    #print(type(FromTo.loc[b,'ULDoor']))
        if int(newpairs.loc[b,'ULDoor']) in EvenDoors and int(newpairs.loc[b,'LdDoor']) in EvenDoors:
            x = abs(EvenDoors.index(int(newpairs.loc[b,'ULDoor'])) - EvenDoors.index(int(newpairs.loc[b,'LdDoor'])))
            if x < 1:
                distance2.loc[b] = 0
            else:
               distance2.loc[b] = DoorWidth * x + DoorSpace * x + 2 * Y
        elif int(newpairs.loc[b,'ULDoor']) in OddDoors and int(newpairs.loc[b,'LdDoor']) in OddDoors:
            x = abs(OddDoors.index(int(newpairs.loc[b,'ULDoor'])) - OddDoors.index(int(newpairs.loc[b,'LdDoor'])))
            if x < 1:
                distance2.loc[b] = 0
            else:
                distance2.loc[b] = DoorWidth * x + DoorSpace * x + 2 * Y
        elif int(newpairs.loc[b,'ULDoor']) in SideDoors and int(newpairs.loc[b,'LdDoor']) in SideDoors:
            distance2.loc[b] = None
        else:
            if int(newpairs.loc[b,'ULDoor']) in OddDoors and int(newpairs.loc[b,'LdDoor']) in EvenDoors:
                x = abs(OddDoors.index(int(newpairs.loc[b,'ULDoor'])) - EvenDoors.index(int(newpairs.loc[b,'LdDoor'])))
                distance2.loc[b] = DoorWidth * x + DoorSpace * x + 2 * Y + DockWidth
            elif int(newpairs.loc[b,'ULDoor']) in EvenDoors and int(newpairs.loc[b,'LdDoor']) in OddDoors:
                x = abs(EvenDoors.index(int(newpairs.loc[b,'ULDoor'])) - OddDoors.index(int(newpairs.loc[b,'LdDoor'])))
                distance2.loc[b] = DoorWidth * x + DoorSpace * x + 2 * Y + DockWidth
    newpairs['Distance'] = distance2 * 2
    newpairs['c_ij'] = newpairs['Distance'] / (h*speed)
    travelCost_df = newpairs['c_ij'] * newpairs['Wgt_y']
    #print(labor_cost_travel_df)
    travelCost = travelCost_df.sum()
    if travelCost <  labor_cost_travel:
        optimal = newpairs
    else:
        newpairs = TempPairs
    i = i + 1

optimalCostdf = optimal.Wgt_y * optimal.c_ij
optimalCost = optimalCostdf.sum()
newpairsCostdf = newpairs.Wgt_y * optimal.c_ij
newpairsCost = newpairsCostdf.sum()
pairsCostdf = pairs.Wgt_y * pairs.c_ij
pairsCost = pairsCostdf.sum()

#Mazen's Code

t = 2
u = .05
#optimalTable = pd.pivot_table(optimal, index = ['ULDoor'], columns = ['LdDoor'], values = ['Wgt_y'], aggfunc = np.sum, margins = True)
#optimalTable = (optimalTable.fillna(0))
#optimalTable = optimalTable.reset_index()
FromToTable = pd.pivot_table(optimal, index = ['ULDoor'], columns = ['LdDoor'], values = ['Wgt_y'], aggfunc = np.sum, margins = True)
FromToTable = (FromToTable.fillna(0))
FromToTable = FromToTable.reset_index()
lambda_j = (FromToTable[('Wgt_y','All')].sum()-FromToTable.loc[(len(FromToTable)-1),('Wgt_y','All')])/(h*t)
numerator = (t*lambda_j)/(u*(u-lambda_j))
#lambda_j = pd.DataFrame(index = range(1,len(optimalTable)) , columns = ['Weight'])
#lambda_j = lambda_j.fillna(0) 
#for counter in range(0,len(optimalTable)-1):
#    if not counter in [104,106,108,110,'All']:
#        lambda_j.iloc[counter] = optimalTable.loc[counter , ('Wgt_y','All')]/(h*t)
lambda_j = pd.DataFrame(index = range(1,len(FromToTable)) , columns = ['Weight'])
lambda_j = lambda_j.fillna(0) 
for counter in range(0,len(FromToTable)-1):
    if not counter in [104,106,108,110,'All']:
        lambda_j.iloc[counter] = FromToTable.loc[counter , ('Wgt_y','All')]/(h*t)
        
        
        
#fik = pd.DataFrame(index = range(1,len(optimalTable)) , columns = ['Sub'])
#fik = fik.fillna(0) 
#for counter2 in range(1,len(optimalTable)-1):
#    if not counter2 in [104,106,108,110,'All']:
#        fik.iloc[counter2] = 2*optimalTable.loc[len(optimalTable)-1,('Wgt_y',counter2)]/(h*t)
fik = pd.DataFrame(index = range(1,len(FromToTable)) , columns = ['Sub'])
fik = fik.fillna(0) 
for counter2 in range(1,len(FromToTable)-1):
    if not counter2 in [104,106,108,110,'All']:
        fik.iloc[counter2] = 2*FromToTable.loc[len(FromToTable)-1,('Wgt_y',counter2)]/(h*t)
                
        
#values = pd.DataFrame(index = range(1,len(optimalTable)) , columns = ['final'])
#values = values.fillna(0)
#for counter3 in range(1,173):
#    values['final'][counter3] = ((t*lambda_j.iloc[counter3]['Weight']*fik.iloc[counter3]['Sub'])/(u*(u -lambda_j.iloc[counter3]['Weight'])))
#abs(values)
values = pd.DataFrame(index = range(1,len(FromToTable)) , columns = ['final'])
values = values.fillna(0)
for counter3 in range(1,173):
    values['final'][counter3] = ((t*lambda_j.iloc[counter3]['Weight']*fik.iloc[counter3]['Sub'])/(u*(u -lambda_j.iloc[counter3]['Weight'])))
abs(values)
#values2 = 0
#for counter4 in range(1,173):
#    values2 += ((t*lambda_j.iloc[counter4]['Weight']*fik.iloc[counter4]['Sub'])/(u*(u -lambda_j.iloc[counter4]['Weight'])))
#    #print(lambda_j.iloc[i]*fik.iloc[i])
#    #print(fik.iloc[i])
#    #print(lambda_j.iloc[i],'this si the lambda')
#values2
values2 = 0
for counter4 in range(1,173):
    values2 += ((t*lambda_j.iloc[counter4]['Weight']*fik.iloc[counter4]['Sub'])/(u*(u -lambda_j.iloc[counter4]['Weight'])))
    #print(lambda_j.iloc[i]*fik.iloc[i])
    #print(fik.iloc[i])
    #print(lambda_j.iloc[i],'this si the lambda')
values2
